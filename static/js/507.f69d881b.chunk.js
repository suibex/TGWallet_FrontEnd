"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[507],{88507:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  offchainLookup: () => (/* binding */ offchainLookup),\n  offchainLookupSignature: () => (/* binding */ offchainLookupSignature)\n});\n\n// UNUSED EXPORTS: ccipRequest, offchainLookupAbiItem\n\n// EXTERNAL MODULE: ./node_modules/viem/_esm/actions/public/call.js + 16 modules\nvar call = __webpack_require__(61990);\n// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/stringify.js\nvar stringify = __webpack_require__(23512);\n// EXTERNAL MODULE: ./node_modules/viem/_esm/errors/base.js + 1 modules\nvar base = __webpack_require__(21627);\n// EXTERNAL MODULE: ./node_modules/viem/_esm/errors/utils.js\nvar utils = __webpack_require__(91218);\n;// ./node_modules/viem/_esm/errors/ccip.js\n\n\n\nclass OffchainLookupError extends base/* BaseError */.C {\n  constructor(_ref) {\n    let {\n      callbackSelector,\n      cause,\n      data,\n      extraData,\n      sender,\n      urls\n    } = _ref;\n    super(cause.shortMessage || 'An error occurred while fetching for an offchain result.', {\n      cause,\n      metaMessages: [...(cause.metaMessages || []), cause.metaMessages?.length ? '' : [], 'Offchain Gateway Call:', urls && ['  Gateway URL(s):', ...urls.map(url => `    ${(0,utils/* getUrl */.I)(url)}`)], `  Sender: ${sender}`, `  Data: ${data}`, `  Callback selector: ${callbackSelector}`, `  Extra data: ${extraData}`].flat(),\n      name: 'OffchainLookupError'\n    });\n  }\n}\nclass OffchainLookupResponseMalformedError extends base/* BaseError */.C {\n  constructor(_ref2) {\n    let {\n      result,\n      url\n    } = _ref2;\n    super('Offchain gateway response is malformed. Response data must be a hex value.', {\n      metaMessages: [`Gateway URL: ${(0,utils/* getUrl */.I)(url)}`, `Response: ${(0,stringify/* stringify */.A)(result)}`],\n      name: 'OffchainLookupResponseMalformedError'\n    });\n  }\n}\nclass OffchainLookupSenderMismatchError extends base/* BaseError */.C {\n  constructor(_ref3) {\n    let {\n      sender,\n      to\n    } = _ref3;\n    super('Reverted sender address does not match target contract address (`to`).', {\n      metaMessages: [`Contract address: ${to}`, `OffchainLookup sender address: ${sender}`],\n      name: 'OffchainLookupSenderMismatchError'\n    });\n  }\n}\n// EXTERNAL MODULE: ./node_modules/viem/_esm/errors/request.js\nvar request = __webpack_require__(72494);\n// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/abi/decodeErrorResult.js\nvar decodeErrorResult = __webpack_require__(74745);\n// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/abi/encodeAbiParameters.js\nvar encodeAbiParameters = __webpack_require__(31376);\n// EXTERNAL MODULE: ./node_modules/viem/_esm/errors/address.js\nvar address = __webpack_require__(3491);\n// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/address/isAddress.js\nvar isAddress = __webpack_require__(74074);\n;// ./node_modules/viem/_esm/utils/address/isAddressEqual.js\n\n\nfunction isAddressEqual(a, b) {\n  if (!(0,isAddress/* isAddress */.P)(a, {\n    strict: false\n  })) throw new address/* InvalidAddressError */.M({\n    address: a\n  });\n  if (!(0,isAddress/* isAddress */.P)(b, {\n    strict: false\n  })) throw new address/* InvalidAddressError */.M({\n    address: b\n  });\n  return a.toLowerCase() === b.toLowerCase();\n}\n// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/data/concat.js\nvar concat = __webpack_require__(52620);\n// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/data/isHex.js\nvar isHex = __webpack_require__(31499);\n;// ./node_modules/viem/_esm/utils/ccip.js\n\n\n\n\n\n\n\n\n\nconst offchainLookupSignature = '0x556f1830';\nconst offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [{\n    name: 'sender',\n    type: 'address'\n  }, {\n    name: 'urls',\n    type: 'string[]'\n  }, {\n    name: 'callData',\n    type: 'bytes'\n  }, {\n    name: 'callbackFunction',\n    type: 'bytes4'\n  }, {\n    name: 'extraData',\n    type: 'bytes'\n  }]\n};\nasync function offchainLookup(client, _ref) {\n  let {\n    blockNumber,\n    blockTag,\n    data,\n    to\n  } = _ref;\n  const {\n    args\n  } = (0,decodeErrorResult/* decodeErrorResult */.W)({\n    data,\n    abi: [offchainLookupAbiItem]\n  });\n  const [sender, urls, callData, callbackSelector, extraData] = args;\n  const {\n    ccipRead\n  } = client;\n  const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function' ? ccipRead.request : ccipRequest;\n  try {\n    if (!isAddressEqual(to, sender)) throw new OffchainLookupSenderMismatchError({\n      sender,\n      to\n    });\n    const result = await ccipRequest_({\n      data: callData,\n      sender,\n      urls\n    });\n    const {\n      data: data_\n    } = await (0,call/* call */.T)(client, {\n      blockNumber,\n      blockTag,\n      data: (0,concat/* concat */.xW)([callbackSelector, (0,encodeAbiParameters/* encodeAbiParameters */.h)([{\n        type: 'bytes'\n      }, {\n        type: 'bytes'\n      }], [result, extraData])]),\n      to\n    });\n    return data_;\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err,\n      data,\n      extraData,\n      sender,\n      urls\n    });\n  }\n}\nasync function ccipRequest(_ref2) {\n  let {\n    data,\n    sender,\n    urls\n  } = _ref2;\n  let error = new Error('An unknown error occurred.');\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const method = url.includes('{data}') ? 'GET' : 'POST';\n    const body = method === 'POST' ? {\n      data,\n      sender\n    } : undefined;\n    try {\n      const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n        body: JSON.stringify(body),\n        method\n      });\n      let result;\n      if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n        result = (await response.json()).data;\n      } else {\n        result = await response.text();\n      }\n      if (!response.ok) {\n        error = new request/* HttpRequestError */.Ci({\n          body,\n          details: result?.error ? (0,stringify/* stringify */.A)(result.error) : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url\n        });\n        continue;\n      }\n      if (!(0,isHex/* isHex */.q)(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url\n        });\n        continue;\n      }\n      return result;\n    } catch (err) {\n      error = new request/* HttpRequestError */.Ci({\n        body,\n        details: err.message,\n        url\n      });\n    }\n  }\n  throw error;\n}\n\n//# sourceURL=../node_modules/viem/_esm/utils/ccip.js%7C92b4cb2ac77915e1b1088bcaa1837823")}}]);